[
    (
        (
            [ /operator!= ( EAppArg Value /l -> TVVar /T = Hole TVVar /T HoleActive Nothing ) ( EAppArg Value /r -> TVVar /T = Hole TVVar /T HoleActive Nothing ) ( EAppVar /T ∀/Data/Algebra/Eq ) -> ∀/Data/Primitive/Boolean
            , Value /Data/Algebra/LessThan
            , Value /Data/Algebra/Equal
            , Value /Data/Algebra/GreaterThan
            , Value /Data/Algebra/NoOrdering
            , /Data/Algebra/compare ( EAppVar /T ∀/Data/Algebra/Ord ) ( EAppArg Value /l -> TVVar /T ) ( EAppArg Value /r -> TVVar /T ) -> ∀/Data/Algebra/Ordering
            , /Data/Algebra/compare ( EAppVar /T ∀/Data/Algebra/POrd ) ( EAppArg Value /l -> TVVar /T ) ( EAppArg Value /r -> TVVar /T ) -> ∀/Data/Algebra/POrdering
            , /operator<= ( EAppArg Value /l -> TVVar /T = Hole TVVar /T HoleActive Nothing ) ( EAppArg Value /r -> TVVar /T = Hole TVVar /T HoleActive Nothing ) ( EAppVar /T ∀/Data/Algebra/Ord ) -> ∀/Data/Primitive/Boolean
            , /operator>= ( EAppArg Value /l -> TVVar /T = Hole TVVar /T HoleActive Nothing ) ( EAppArg Value /r -> TVVar /T = Hole TVVar /T HoleActive Nothing ) ( EAppVar /T ∀/Data/Algebra/Ord ) -> ∀/Data/Primitive/Boolean
            , /operator< ( EAppArg Value /l -> TVVar /T = Hole TVVar /T HoleActive Nothing ) ( EAppArg Value /r -> TVVar /T = Hole TVVar /T HoleActive Nothing ) ( EAppVar /T ∀/Data/Algebra/Ord ) -> ∀/Data/Primitive/Boolean
            , /operator> ( EAppArg Value /l -> TVVar /T = Hole TVVar /T HoleActive Nothing ) ( EAppArg Value /r -> TVVar /T = Hole TVVar /T HoleActive Nothing ) ( EAppVar /T ∀/Data/Algebra/Ord ) -> ∀/Data/Primitive/Boolean
            , /operator++ ( EAppArg Value /l -> TVVar /T = Hole TVVar /T HoleActive Nothing ) ( EAppArg Value /r -> TVVar /T = Hole TVVar /T HoleActive Nothing ) ( EAppVar /T ∀/Data/Algebra/Semigroup ) -> TVVar /T
            , /Data/Algebra/mempty ( EAppVar /T ∀/Data/Algebra/Monoid ) -> TVVar /T
            , /Data/Algebra/inverse ( EAppVar /T ∀/Data/Algebra/Group ) ( EAppArg Value /t -> TVVar /T ) -> TVVar /T
            ]
        ,
            [ CGType
            , CGType
            , CGType
            , CGType
            , CGType
            , CGType
            , CGType
            , CGType
            , CGType
            , CGType
            , CGType
            , CGType
            , CGType
            , CGType
            , CGType
            , CGType
            , CGType
            , CGType
            , CGClass
                ( False
                , /Data/Algebra/CommutativeMonoid
                , []
                , Just "The [CommutativeMonoid] builds on top of the [Monoid].
                  It is also called an Abelian Monoid
                  Here, integers with addition are a [CommutativeMonoid], but [String]s are not."
                )
            , CGClass
                ( False
                , /Data/Algebra/Eq
                ,
                    [ ∀/Data/Algebra/POrd
                    , ∀/Data/Algebra/Semigroup
                    ]
                , Just "The Eq class is used to define values which can be compared for equality.
                  While naive tuple equality often works, some types have equality that behaves differently and must be defined.
                  For example, a TreeSet can insert items in different order and produce different trees, but with equal sets.
                  There are only two operations for eq: [operator==] and [operator!=]./operator==</Data/Algebra/Eq $T>($T l, $T r) -> BooleanThis checks whether two items are equal.
                  Note that it only compares like items with each other, not that you can compare apples to oranges. If something can be compared for order, it should also be comparable for equality by the following relationship: "
                )
            , CGClass
                ( False
                , /Data/Algebra/Group
                , []
                , Just "The [Group] builds on top of the [Monoid] (not necessarily the [CommutativeMonoid]).
                  It adds an inverse operation that finds the opposite of an element.
                  For integers with addition, negation with [operator~] would be the inverse.
                  Something like [String]s would not have an inverse, so it wouldn't be a [Group]."
                )
            , CGClass
                ( False
                , /Data/Algebra/Monoid
                ,
                    [ ∀/Data/Algebra/CommutativeMonoid
                    , ∀/Data/Algebra/Group
                    ]
                , Just "The [Monoid] builds on top of the [Semigroup].
                  It adds the identity value [mempty].
                  The integers with addition form a [Monoid], and 0 is the value for [mempty].
                  Another example is [String] where "" is the value for [mempty]  "
                )
            , CGClass
                ( False
                , /Data/Algebra/Ord
                , [ ∀/Data/Primitive/Number ]
                , Just "Ord is used to define types which can be strictly ordered.
                  Every element, when compared must have one of the following [Ordering] relationships: "
                )
            , CGClass
                ( True
                , /Data/Algebra/Ordering
                ,
                    [ /Data/Algebra/LessThan
                    , /Data/Algebra/Equal
                    , /Data/Algebra/GreaterThan
                    ]
                , Just "The Orderings can relate any like items of Ord. "
                )
            , CGClass
                ( False
                , /Data/Algebra/POrd
                , [ ∀/Data/Algebra/Ord ]
                , Just "In addition to [Ord], [POrd] defines a partial ordering.
                  Partially ordered items can be compared, but may result in [NoOrdering]: "
                )
            , CGClass
                ( True
                , /Data/Algebra/POrdering
                ,
                    [ ∀/Data/Algebra/Ordering
                    , /Data/Algebra/NoOrdering
                    ]
                , Just "As an example, sets can be partially ordered by the subset operation.
                  One set A <= B when A is a subset of B.
                  An ordered example is {1} <= {1, 2}.
                  But, two sets like {1} and {2} have no ordering between them."
                )
            , CGClass
                ( False
                , /Data/Algebra/Semigroup
                , [ ∀/Data/Algebra/Monoid ]
                , Just "A semigroup is a type combined with an associative operation called [operator++].
                  For example, integers with the addition operation are a semigroup. "
                )
            ]
        ,
            [ /Catln/#md
                ( EAppArg Value /text -> /Data/String = "# Catln Core Abstract Algebra Types
                These types define some of the basic relationship between types and ways classes can relate to themselves." )
            , /Catln/#md
                ( EAppArg Value /text -> /Data/String = "The Eq class is used to define values which can be compared for equality.
                While naive tuple equality often works, some types have equality that behaves differently and must be defined.
                For example, a TreeSet can insert items in different order and produce different trees, but with equal sets.
                There are only two operations for eq: [operator==] and [operator!=]." )
            , /Catln/#md
                ( EAppArg Value /text -> /Data/String = "/operator==</Data/Algebra/Eq $T>($T l, $T r) -> Boolean" )
            , /Catln/#md
                ( EAppArg Value /text -> /Data/String = "This checks whether two items are equal.
                Note that it only compares like items with each other, not that you can compare apples to oranges." )
            , /Catln/#md
                ( EAppArg Value /text -> /Data/String = "It is the opposite of [operator==] leading to the simple definition:" )
            , /Catln/#md
                ( EAppArg Value /text -> /Data/String = "/operator!=(l, r) = ~(l == r)
                Given this, creating an instance of Eq only requires defining equality and the != can be produced automatically." )
            , /Catln/#md
                ( EAppArg Value /text -> /Data/String = "## Ordering" )
            , /Catln/#md
                ( EAppArg Value /text -> /Data/String = "Ordering is used to define operations that have a natural ability to be ordered or sorted.
                Some examples include numbers which are sorted from smallest to largest or strings which are sorted alphabetically." )
            , /Catln/#md
                ( EAppArg Value /text -> /Data/String = "There are two different forms of ordering:" )
            , /Catln/#md
                ( EAppArg Value /text -> /Data/String = "Ord is used to define types which can be strictly ordered.
                Every element, when compared must have one of the following [Ordering] relationships:" )
            , /Catln/#md
                ( EAppArg Value /text -> /Data/String = "The Orderings can relate any like items of Ord. " )
            , /Catln/#md
                ( EAppArg Value /text -> /Data/String = "In addition to [Ord], [POrd] defines a partial ordering.
                Partially ordered items can be compared, but may result in [NoOrdering]:" )
            , /Catln/#md
                ( EAppArg Value /text -> /Data/String = "As an example, sets can be partially ordered by the subset operation.
                One set A <= B when A is a subset of B.
                An ordered example is {1} <= {1, 2}.
                But, two sets like {1} and {2} have no ordering between them." )
            , /Catln/#md
                ( EAppArg Value /text -> /Data/String = "There are a few nice properties about ordering." )
            , /Catln/#md
                ( EAppArg Value /text -> /Data/String = "This means that something fully ordered can still take advantage of many of the same functions as partially ordered ones.
                It just usually has a more specific result." )
            , /Catln/#md
                ( EAppArg Value /text -> /Data/String = "The only major function for ordering is [compare].
                Comparing two [Ord] will result in an [Ordering].
                Likewise, comparing two partially orderables [POrd] results in a [POrdering]." )
            , /Catln/#md
                ( EAppArg Value /text -> /Data/String = "### Operators for ordering
                Besides compare, there are also some operators to make using ordering easier." )
            , /Catln/#md
                ( EAppArg Value /text -> /Data/String = "If something can be compared for order, it should also be comparable for equality by the following relationship:" )
            , /Catln/#md
                ( EAppArg Value /text -> /Data/String = "/operator==<POrd $T>($T l, $T r) = compare(l=l, r=r) == Equal" )
            , /Catln/#md
                ( EAppArg Value /text -> /Data/String = "### Ordering utility functions" )
            , /Catln/#md
                ( EAppArg Value /text -> /Data/String = "max<Ord $T>($T l, $T r) -> $T = if l >= r then l else r" )
            , /Catln/#md
                ( EAppArg Value /text -> /Data/String = "min<Ord $T>($T l, $T r) -> $T = if l <= r then l else r" )
            , /Catln/#md
                ( EAppArg Value /text -> /Data/String = "TODO: Tests and properties for compare" )
            , /Catln/#md
                ( EAppArg Value /text -> /Data/String = "## Semigroup" )
            , /Catln/#md
                ( EAppArg Value /text -> /Data/String = "A semigroup is a type combined with an associative operation called [operator++].
                For example, integers with the addition operation are a semigroup." )
            , /Catln/#md
                ( EAppArg Value /text -> /Data/String = "The [Monoid] builds on top of the [Semigroup].
                It adds the identity value [mempty].
                The integers with addition form a [Monoid], and 0 is the value for [mempty].
                Another example is [String] where "" is the value for [mempty]" )
            , /Catln/#md
                ( EAppArg Value /text -> /Data/String = "We can test to verify that [mempty] works with both the left and right." )
            , /Catln/#md
                ( EAppArg Value /text -> /Data/String = "mconcat<Monoid $T>(List<$T> lst) = lst.fold(operator++, mempty)" )
            , /Catln/#md
                ( EAppArg Value /text -> /Data/String = "Using the [Monoid], it is possible to combine a list of monoids together." )
            , /Catln/#md
                ( EAppArg Value /text -> /Data/String = "The [CommutativeMonoid] builds on top of the [Monoid].
                It is also called an Abelian Monoid
                Here, integers with addition are a [CommutativeMonoid], but [String]s are not." )
            , /Catln/#md
                ( EAppArg Value /text -> /Data/String = "We can test to ensure that all [CommutativeMonoid]s satisfy the commutativity requirement." )
            , /Catln/#md
                ( EAppArg Value /text -> /Data/String = "The [Group] builds on top of the [Monoid] (not necessarily the [CommutativeMonoid]).
                It adds an inverse operation that finds the opposite of an element.
                For integers with addition, negation with [operator~] would be the inverse.
                Something like [String]s would not have an inverse, so it wouldn't be a [Group]." )
            ]
        )
    , ct
        ( CStr "/repo/dir/stack/core/algebra.ct" )
    ,
        [ ct
            ( CStr "/repo/dir/stack/core/primitives.ct" )
        , ct
            ( CStr "/repo/dir/stack/core/compile.ct" )
        ]
    )
,
    (
        (
            [ Value /Catln/IO
            , /Catln/exit ( EAppArg Value /val -> /Data/Primitive/Integer ) ( EAppArg Value /this -> /Catln/IO ) -> /Catln/IO
            , /Catln/println ( EAppArg Value /msg -> /Data/String ) ( EAppArg Value /this -> /Catln/IO ) -> /Catln/IO
            , /Catln/#md ( EAppArg Value /text -> /Data/String )
            , /Catln/#name ( EAppArg Value /name -> /Data/String )
            , Value /Catln/#else
            , /Catln/#runtime ( EAppArg Value /k -> /Data/String )
            , Value /Catln/#argStart
            , Value /Catln/#argEnd
            , /Catln/#assert ( EAppArg Value /test -> ∀/Data/Primitive/Boolean )
            , /Catln/#assert ( EAppArg Value /test -> ∀/Data/Primitive/Boolean ) ( EAppArg Value /msg -> /Data/String )
            , /Catln/#print ( EAppArg Value /p -> ∀/Catln/Doc/DShow )
            , Value /Catln/#test
            , Value /Catln/#example
            , /operator?-> ( EAppArg Value /l= Hole TopType HoleActive Nothing ) ( EAppArg Value /r= Hole TopType HoleActive Nothing ) -> ∀/Data/Primitive/Boolean
            , /Catln/CatlnResult ( EAppArg Value /name -> /Data/String ) ( EAppArg Value /contents -> /Data/String )
            , /Catln/www ( EAppArg Value /html -> /Data/String ) -> /Catln/CatlnResult
                ( /name=/Data/String
                , /contents=/Data/String
                ) = /Catln/CatlnResult
                ( EAppArg Value /name -> /Data/String = "index.html" )
                ( EAppArg Value /contents -> TVArg /html = ( Value /html ↦ TVArg /html ) )
            , /Catln/llvm ( EAppArg Value /c ) -> /Catln/CatlnResult..
            , Value /Catln/Then
            , Value /Catln/Else
            , /Catln/ThenElse/fromBool ( EAppArg Value /v -> ∀/Data/Primitive/Boolean ) -> ∀/Catln/ThenElse
            , /Catln/ThenElse/fromBool ( EAppArg Value /v -> /Data/Primitive/True = Value /Data/Primitive/True ) -> /Catln/Then = Value /Catln/Then
            , /Catln/ThenElse/fromBool ( EAppArg Value /v -> /Data/Primitive/False = Value /Data/Primitive/False ) -> /Catln/Else = Value /Catln/Else
            ]
        ,
            [ CGType
            , CGType
            , CGType
            , CGType
            , CGType
            , CGType
            , CGType
            , CGType
            , CGType
            , CGType
            , CGType
            , CGType
            , CGType
            , CGType
            , CGType
            , CGType
            , CGType
            , CGType
            , CGType
            , CGType
            , CGClass
                ( True
                , /Catln/ThenElse
                ,
                    [ /Catln/Then
                    , /Catln/Else
                    ]
                , Just ""
                )
            ]
        ,
            [ /Catln/#md
                ( EAppArg Value /text -> /Data/String = "# Catln Core Compiling Types and Annotations" )
            , /Catln/#md
                ( EAppArg Value /text -> /Data/String = "## IO" )
            , /Catln/#md
                ( EAppArg Value /text -> /Data/String = "## Core Annotations
                The core annotations are all of the annotations used by the compiler and the web docs program." )
            , /Catln/#md
                ( EAppArg Value /text -> /Data/String = "## Build-in Type Macros" )
            , /Catln/#md
                ( EAppArg Value /text -> /Data/String = "## Result Classes" )
            ]
        )
    , ct
        ( CStr "/repo/dir/stack/core/compile.ct" )
    ,
        [ ct
            ( CStr "/repo/dir/stack/core/primitives.ct" )
        , ct
            ( CStr "/repo/dir/stack/core/data.ct" )
        , ct
            ( CStr "/repo/dir/stack/core/webdoc.ct" )
        ]
    )
,
    (
        (
            [ Value /Data/String
            , /operator== ( EAppArg Value /l -> /Data/String = Hole /Data/String HoleActive Nothing ) ( EAppArg Value /r -> /Data/String = Hole /Data/String HoleActive Nothing ) -> ∀/Data/Primitive/Boolean
            , /Data/toString ( EAppArg Value /this -> /Data/String ) -> /Data/String
            , /Data/toString ( EAppArg Value /this -> /Data/String ) -> TVArg /this = ( Value /this ↦ TVArg /this )
            , /Data/toString ( EAppArg Value /this -> /Data/Primitive/Integer ) -> /Data/String
            , /Context ( EAppVar /V TopType ) ( EAppArg Value /value -> TVVar /V ) ( EAppSpread Hole TopType HoleActive Nothing )
            , /ContextIn ( EAppVar /V TopType ) ( EAppArg Value /value -> TVVar /V ) ( EAppSpread Hole TopType HoleActive Nothing )
            , /ContextOut ( EAppVar /V TopType ) ( EAppArg Value /value -> TVVar /V ) ( EAppSpread Hole TopType HoleActive Nothing )
            , /Context ( EAppVar /T TopType ) ( EAppVar /V TopType ) ( EAppArg Value /value -> TVVar /V ) ( EAppSpread Hole TopType HoleActive Nothing ) | /operator?->
                ( EAppArg Value /l -> /ContextIn [ /V=TopType ] ( /value=TopType ) .. = /ContextIn ( EAppVar /V TVVar /V ) ( EAppArg Value /value -> TVVar /V = Hole TVVar /V HoleActive Nothing ) ( EAppSpread Hole TopType HoleActive Nothing ) ) ( EAppArg Value /r -> TVVar /T = Hole TVVar /T HoleActive Nothing ) -> TVVar /T
            , Value /Data/None
            , /Data/Cons ( EAppVar /T TopType ) ( EAppArg Value /head -> TVVar /T ) ( EAppArg Value /tail -> ∀/Data/ConsList )
            , Value /Data/Nil
            , /Data/length ( EAppArg Value /this -> /Data/Nil ) -> /Data/Primitive/Integer = 0
            , /Data/length
                ( EAppArg Value /this -> /Data/Cons [ /T=TopType ]
                    ( /tail=~ConsList [ /T=TVVar /T ]
                    , /head=TVVar /T
                    ) = /Data/Cons ( EAppArg Value /head )
                    ( EAppArg Value /tail ->
                        ( /Data/Nil | /Data/Cons [ /T=TopType ]
                            ( /tail=~ConsList [ /T=TVVar /T ]
                            , /head=TVVar /T
                            )
                        )
                    )
                ) ->
                ( /Data/Primitive/Integer | /operator+
                    ( /l=/Data/Primitive/Integer
                    , /r=/Data/Primitive/Integer
                    )
                ) = /operator+
                ( EAppArg Value /l -> /Data/Primitive/Integer = 1 )
                ( EAppArg Value /r -> /Data/Primitive/Integer =
                    ( /Data/length
                        ( EAppArg Value /this -> TVArg /tail = ( Value /tail ↦ TVArg /tail ) ) ↦ /Data/Primitive/Integer
                    )
                )
            , /Data/enum ( EAppVar /T ∀/Data/Enum ) -> ∀/Data/Set
            ]
        ,
            [ CGType
            , CGType
            , CGType
            , CGType
            , CGType
            , CGType
            , CGType
            , CGType
            , CGType
            , CGType
            , CGType
            , CGClass
                ( False
                , /Data/String
                , [ /Data/String ]
                , Just ""
                )
            , CGClass
                ( True
                , /Data/ConsList
                ,
                    [ /Data/Cons [ /T=TVVar /T ]
                        ( /tail=~ConsList [ /T=TVVar /T ]
                        , /head=TVVar /T
                        )
                    , /Data/Nil
                    ]
                , Just "The simplest kind of list can be created by prepending.
                  A [ConsList] defines a list either by prepending to a list or with an empty list."
                )
            , CGClass
                ( False
                , /Data/Enum
                , []
                , Just "[Enum] represents a type which can be enumerated.
                  It defines a single function [enum] which lists all of the values in the type."
                )
            , CGClass
                ( False
                , /Data/Functor
                ,
                    [ ∀/Data/Option
                    , ∀/Data/ConsList
                    ]
                , Just "A [Functor] is a basic property of a collection.
                  It has a single operation [fmap] that applies a function to each element in the collection.$F[$A: $T].fmap[$F: Functor](fn(v: $A) -> $B) -> $F[$B: $T]  "
                )
            , CGClass
                ( False
                , /Data/List
                , []
                , Just ""
                )
            , CGClass
                ( True
                , /Data/Option
                ,
                    [ TVVar /T
                    , /Data/None
                    ]
                , Just "[Option] defines a type that might have a value or [None].
                  It can be used to handle operations that are uncertain if they can produce a response."
                )
            , CGClass
                ( False
                , /Data/Set
                , []
                , Just ""
                )
            ]
        ,
            [ /Catln/#md
                ( EAppArg Value /text -> /Data/String = "# Catln Core Data Types
                These define the basic data types used in the language." )
            , /Catln/#md
                ( EAppArg Value /text -> /Data/String = "## String" )
            , /Catln/#md
                ( EAppArg Value /text -> /Data/String = "## Context" )
            , /Catln/#md
                ( EAppArg Value /text -> /Data/String = "## Collections
                Collections are contains that hold elements of a type inside them." )
            , /Catln/#md
                ( EAppArg Value /text -> /Data/String = "A [Functor] is a basic property of a collection.
                It has a single operation [fmap] that applies a function to each element in the collection." )
            , /Catln/#md
                ( EAppArg Value /text -> /Data/String = "$F[$A: $T].fmap[$F: Functor](fn(v: $A) -> $B) -> $F[$B: $T]" )
            , /Catln/#md
                ( EAppArg Value /text -> /Data/String = "## Collections" )
            , /Catln/#md
                ( EAppArg Value /text -> /Data/String = "[Option] defines a type that might have a value or [None].
                It can be used to handle operations that are uncertain if they can produce a response." )
            , /Catln/#md
                ( EAppArg Value /text -> /Data/String = "None.fmap(fn) = None" )
            , /Catln/#md
                ( EAppArg Value /text -> /Data/String = "$T.fmap(fn($T)) = fn(this)" )
            , /Catln/#md
                ( EAppArg Value /text -> /Data/String = "A [List] is a collection of zero or more ordered items." )
            , /Catln/#md
                ( EAppArg Value /text -> /Data/String = "The simplest kind of list can be created by prepending.
                A [ConsList] defines a list either by prepending to a list or with an empty list." )
            , /Catln/#md
                ( EAppArg Value /text -> /Data/String = "/operator+:<$T>($T l, ConsList<$T> r) = Cons(head=l, tail=r)
                [operator+:] is a utility operator to prepend an element onto a [List]." )
            , /Catln/#md
                ( EAppArg Value /text -> /Data/String = "#### [length]
                The [length] of a [List] is the number of items inside of it." )
            , /Catln/#md
                ( EAppArg Value /text -> /Data/String = "Nil.fmap(fn) = Nil" )
            , /Catln/#md
                ( EAppArg Value /text -> /Data/String = "Cons(head, tail).fmap(fn) = Cons(head=fn(head), tail=tail.fmap(fn))" )
            , /Catln/#md
                ( EAppArg Value /text -> /Data/String = "A [Set] is a collection of zero or more unique items.
                It is not ordered." )
            , /Catln/#md
                ( EAppArg Value /text -> /Data/String = "[Enum] represents a type which can be enumerated.
                It defines a single function [enum] which lists all of the values in the type." )
            ]
        )
    , ct
        ( CStr "/repo/dir/stack/core/data.ct" )
    ,
        [ ct
            ( CStr "/repo/dir/stack/core/primitives.ct" )
        ]
    )
,
    (
        ( []
        , []
        ,
            [ /Catln/#md
                ( EAppArg Value /text -> /Data/String = "# Catln Core Library
                This is the Catln core library.
                It defines the fundamental units of the language, core data types, basic compilation, and standard methods.
                All Catln files will automatically import the core library." )
            ]
        )
    , ct
        ( CStr "/repo/dir/stack/core/main.ct" )
    ,
        [ ct
            ( CStr "/repo/dir/stack/core/algebra.ct" )
        , ct
            ( CStr "/repo/dir/stack/core/primitives.ct" )
        , ct
            ( CStr "/repo/dir/stack/core/data.ct" )
        , ct
            ( CStr "/repo/dir/stack/core/compile.ct" )
        , ct
            ( CStr "/repo/dir/stack/core/webdoc.ct" )
        ]
    )
,
    (
        (
            [ Value /
            , Value /Data/Primitive/True
            , Value /Data/Primitive/False
            , /operator== ( EAppArg Value /l -> ∀/Data/Primitive/Boolean = Hole ∀/Data/Primitive/Boolean HoleActive Nothing ) ( EAppArg Value /r -> ∀/Data/Primitive/Boolean = Hole ∀/Data/Primitive/Boolean HoleActive Nothing ) -> ∀/Data/Primitive/Boolean
            , /operator== ( EAppArg Value /l -> /Data/Primitive/True = Hole /Data/Primitive/True HoleActive Nothing ) ( EAppArg Value /r -> /Data/Primitive/True = Hole /Data/Primitive/True HoleActive Nothing ) -> /Data/Primitive/True = Value /Data/Primitive/True
            , /operator== ( EAppArg Value /l -> /Data/Primitive/True = Hole /Data/Primitive/True HoleActive Nothing ) ( EAppArg Value /r -> /Data/Primitive/False = Hole /Data/Primitive/False HoleActive Nothing ) -> /Data/Primitive/False = Value /Data/Primitive/False
            , /operator== ( EAppArg Value /l -> /Data/Primitive/False = Hole /Data/Primitive/False HoleActive Nothing ) ( EAppArg Value /r -> /Data/Primitive/True = Hole /Data/Primitive/True HoleActive Nothing ) -> /Data/Primitive/False = Value /Data/Primitive/False
            , /operator== ( EAppArg Value /l -> /Data/Primitive/False = Hole /Data/Primitive/False HoleActive Nothing ) ( EAppArg Value /r -> /Data/Primitive/False = Hole /Data/Primitive/False HoleActive Nothing ) -> /Data/Primitive/True = Value /Data/Primitive/True
            , /operator~ ( EAppArg Value /a -> ∀/Data/Primitive/Boolean = Hole ∀/Data/Primitive/Boolean HoleActive Nothing ) -> ∀/Data/Primitive/Boolean
            , /operator~ ( EAppArg Value /a -> /Data/Primitive/True = Hole /Data/Primitive/True HoleActive Nothing ) -> /Data/Primitive/False = Value /Data/Primitive/False
            , /operator~ ( EAppArg Value /a -> /Data/Primitive/False = Hole /Data/Primitive/False HoleActive Nothing ) -> /Data/Primitive/True = Value /Data/Primitive/True
            , /operator&& ( EAppArg Value /l -> ∀/Data/Primitive/Boolean = Hole ∀/Data/Primitive/Boolean HoleActive Nothing ) ( EAppArg Value /r -> ∀/Data/Primitive/Boolean = Hole ∀/Data/Primitive/Boolean HoleActive Nothing ) -> ∀/Data/Primitive/Boolean
            , /operator&& ( EAppArg Value /l -> /Data/Primitive/True = Hole /Data/Primitive/True HoleActive Nothing ) ( EAppArg Value /r -> /Data/Primitive/True = Hole /Data/Primitive/True HoleActive Nothing ) -> /Data/Primitive/True = Value /Data/Primitive/True
            , /operator&& ( EAppArg Value /l -> ∀/Data/Primitive/Boolean = Hole ∀/Data/Primitive/Boolean HoleActive Nothing ) ( EAppArg Value /r -> /Data/Primitive/False = Hole /Data/Primitive/False HoleActive Nothing ) -> /Data/Primitive/False = Value /Data/Primitive/False
            , /operator&& ( EAppArg Value /l -> /Data/Primitive/False = Hole /Data/Primitive/False HoleActive Nothing ) ( EAppArg Value /r -> ∀/Data/Primitive/Boolean = Hole ∀/Data/Primitive/Boolean HoleActive Nothing ) -> /Data/Primitive/False = Value /Data/Primitive/False
            , /operator|| ( EAppArg Value /l -> ∀/Data/Primitive/Boolean = Hole ∀/Data/Primitive/Boolean HoleActive Nothing ) ( EAppArg Value /r -> ∀/Data/Primitive/Boolean = Hole ∀/Data/Primitive/Boolean HoleActive Nothing ) -> ∀/Data/Primitive/Boolean
            , /operator|| ( EAppArg Value /l -> /Data/Primitive/True = Hole /Data/Primitive/True HoleActive Nothing ) ( EAppArg Value /r -> ∀/Data/Primitive/Boolean = Hole ∀/Data/Primitive/Boolean HoleActive Nothing ) -> /Data/Primitive/True = Value /Data/Primitive/True
            , /operator|| ( EAppArg Value /l -> ∀/Data/Primitive/Boolean = Hole ∀/Data/Primitive/Boolean HoleActive Nothing ) ( EAppArg Value /r -> /Data/Primitive/True = Hole /Data/Primitive/True HoleActive Nothing ) -> /Data/Primitive/True = Value /Data/Primitive/True
            , /operator|| ( EAppArg Value /l -> /Data/Primitive/False = Hole /Data/Primitive/False HoleActive Nothing ) ( EAppArg Value /r -> /Data/Primitive/False = Hole /Data/Primitive/False HoleActive Nothing ) -> /Data/Primitive/False = Value /Data/Primitive/False
            , /operator^ ( EAppArg Value /l -> ∀/Data/Primitive/Boolean = Hole ∀/Data/Primitive/Boolean HoleActive Nothing ) ( EAppArg Value /r -> ∀/Data/Primitive/Boolean = Hole ∀/Data/Primitive/Boolean HoleActive Nothing ) -> ∀/Data/Primitive/Boolean
            , /operator^ ( EAppArg Value /l -> /Data/Primitive/True = Hole /Data/Primitive/True HoleActive Nothing ) ( EAppArg Value /r -> /Data/Primitive/True = Hole /Data/Primitive/True HoleActive Nothing ) -> /Data/Primitive/False = Value /Data/Primitive/False
            , /operator^ ( EAppArg Value /l -> /Data/Primitive/True = Hole /Data/Primitive/True HoleActive Nothing ) ( EAppArg Value /r -> /Data/Primitive/False = Hole /Data/Primitive/False HoleActive Nothing ) -> /Data/Primitive/True = Value /Data/Primitive/True
            , /operator^ ( EAppArg Value /l -> /Data/Primitive/False = Hole /Data/Primitive/False HoleActive Nothing ) ( EAppArg Value /r -> /Data/Primitive/True = Hole /Data/Primitive/True HoleActive Nothing ) -> /Data/Primitive/True = Value /Data/Primitive/True
            , /operator^ ( EAppArg Value /l -> /Data/Primitive/False = Hole /Data/Primitive/False HoleActive Nothing ) ( EAppArg Value /r -> /Data/Primitive/False = Hole /Data/Primitive/False HoleActive Nothing ) -> /Data/Primitive/False = Value /Data/Primitive/False
            , Value /Data/Primitive/Integer
            , Value /Data/Primitive/Float
            , /operator- ( EAppArg Value /a -> /Data/Primitive/Integer = Hole /Data/Primitive/Integer HoleActive Nothing ) -> /Data/Primitive/Integer
            , /operator- ( EAppArg Value /l -> /Data/Primitive/Integer = Hole /Data/Primitive/Integer HoleActive Nothing ) ( EAppArg Value /r -> /Data/Primitive/Integer = Hole /Data/Primitive/Integer HoleActive Nothing ) -> /Data/Primitive/Integer
            , /operator+ ( EAppArg Value /l -> /Data/Primitive/Integer = Hole /Data/Primitive/Integer HoleActive Nothing ) ( EAppArg Value /r -> /Data/Primitive/Integer = Hole /Data/Primitive/Integer HoleActive Nothing ) -> /Data/Primitive/Integer
            , /operator* ( EAppArg Value /l -> /Data/Primitive/Integer = Hole /Data/Primitive/Integer HoleActive Nothing ) ( EAppArg Value /r -> /Data/Primitive/Integer = Hole /Data/Primitive/Integer HoleActive Nothing ) -> /Data/Primitive/Integer
            , /operator<= ( EAppArg Value /l -> /Data/Primitive/Integer = Hole /Data/Primitive/Integer HoleActive Nothing ) ( EAppArg Value /r -> /Data/Primitive/Integer = Hole /Data/Primitive/Integer HoleActive Nothing ) -> ∀/Data/Primitive/Boolean
            , /operator>= ( EAppArg Value /l -> /Data/Primitive/Integer = Hole /Data/Primitive/Integer HoleActive Nothing ) ( EAppArg Value /r -> /Data/Primitive/Integer = Hole /Data/Primitive/Integer HoleActive Nothing ) -> ∀/Data/Primitive/Boolean
            , /operator< ( EAppArg Value /l -> /Data/Primitive/Integer = Hole /Data/Primitive/Integer HoleActive Nothing ) ( EAppArg Value /r -> /Data/Primitive/Integer = Hole /Data/Primitive/Integer HoleActive Nothing ) -> ∀/Data/Primitive/Boolean
            , /operator> ( EAppArg Value /l -> /Data/Primitive/Integer = Hole /Data/Primitive/Integer HoleActive Nothing ) ( EAppArg Value /r -> /Data/Primitive/Integer = Hole /Data/Primitive/Integer HoleActive Nothing ) -> ∀/Data/Primitive/Boolean
            , /operator== ( EAppArg Value /l -> /Data/Primitive/Integer = Hole /Data/Primitive/Integer HoleActive Nothing ) ( EAppArg Value /r -> /Data/Primitive/Integer = Hole /Data/Primitive/Integer HoleActive Nothing ) -> ∀/Data/Primitive/Boolean
            , /operator!= ( EAppArg Value /l -> /Data/Primitive/Integer = Hole /Data/Primitive/Integer HoleActive Nothing ) ( EAppArg Value /r -> /Data/Primitive/Integer = Hole /Data/Primitive/Integer HoleActive Nothing ) -> ∀/Data/Primitive/Boolean
            ]
        ,
            [ CGType
            , CGType
            , CGType
            , CGType
            , CGType
            , CGType
            , CGType
            , CGType
            , CGType
            , CGType
            , CGType
            , CGType
            , CGType
            , CGType
            , CGType
            , CGType
            , CGType
            , CGType
            , CGClass
                ( False
                , /Data/Primitive/Integer
                , [ /Data/Primitive/Integer ]
                , Just ""
                )
            , CGClass
                ( False
                , /Data/Primitive/Boolean
                ,
                    [ ∀/Data/Primitive/Boolean
                    , ∀/Data/Primitive/Number
                    ]
                , Just " "
                )
            , CGClass
                ( False
                , /Data/Primitive/Integer
                , [ /Data/Primitive/Integer ]
                , Just ""
                )
            , CGClass
                ( False
                , /Data/Primitive/Boolean
                , [ ∀/Data/Primitive/Boolean ]
                , Just ""
                )
            , CGClass
                ( True
                , /Data/Primitive/Boolean
                ,
                    [ /Data/Primitive/True
                    , /Data/Primitive/False
                    ]
                , Just ""
                )
            , CGClass
                ( True
                , /Data/Primitive/Number
                ,
                    [ /Data/Primitive/Integer
                    , /Data/Primitive/Float
                    ]
                , Just ""
                )
            ]
        ,
            [ /Catln/#md
                ( EAppArg Value /text -> /Data/String = "# Catln Core Primitives
                These types some of the basic types used in Catln." )
            , /Catln/#md
                ( EAppArg Value /text -> /Data/String = "## Anonymous type" )
            , /Catln/#md
                ( EAppArg Value /text -> /Data/String = "## Booleans" )
            , /Catln/#md
                ( EAppArg Value /text -> /Data/String = "enum<Boolean> = [False, True]" )
            , /Catln/#md
                ( EAppArg Value /text -> /Data/String = "## Integers" )
            , /Catln/#md
                ( EAppArg Value /text -> /Data/String = "### Commutative Group" )
            , /Catln/#md
                ( EAppArg Value /text -> /Data/String = "mempty<Integer $T> = 0" )
            , /Catln/#md
                ( EAppArg Value /text -> /Data/String = "mappend<Integer $T>($T l, $T r) = l + r" )
            , /Catln/#md
                ( EAppArg Value /text -> /Data/String = "inverse<Integer $T>($T t) = -t" )
            ]
        )
    , ct
        ( CStr "/repo/dir/stack/core/primitives.ct" )
    ,
        [ ct
            ( CStr "/repo/dir/stack/core/algebra.ct" )
        , ct
            ( CStr "/repo/dir/stack/core/data.ct" )
        ]
    )
,
    (
        (
            [ /Catln/Doc/dshow ( EAppArg Value /s -> ∀/Catln/Doc/DShow ) -> TVArg /s = ( Value /s ↦ TVArg /s )
            , /Catln/Doc/Show/MD ( EAppArg Value /text -> /Data/String )
            , /Catln/Doc/dshow
                ( EAppArg Value /s -> /Catln/#md ( /text=TopType ) = /Catln/#md ( EAppArg Value /text -> ~String ) ) -> /Catln/Doc/Show/MD ( /text=~String ) = /Catln/Doc/Show/MD ( EAppArg Value /text -> TVArg /text = Value /text )
            , /Catln/Doc/dshow
                ( EAppArg Value /s -> /Catln/#print ( /p=TopType ) = /Catln/#print ( EAppArg Value /p ) ) -> TVArg /p = Value /p
            , Value /Catln/Doc/#listProgram
            , Value /Catln/Doc/Show/ListProgram
            , /Catln/Doc/dshow ( EAppArg Value /s -> /Catln/Doc/#listProgram = Value /Catln/Doc/#listProgram ) -> /Catln/Doc/Show/ListProgram = Value /Catln/Doc/Show/ListProgram
            , Value /Catln/Doc/#type
            , Value /Catln/Doc/Show/TypePage
            , /Catln/Doc/dshow ( EAppArg Value /s -> /Catln/Doc/#type = Value /Catln/Doc/#type ) -> /Catln/Doc/Show/TypePage = Value /Catln/Doc/Show/TypePage
            , Value /Catln/Doc/#class
            , Value /Catln/Doc/Show/ClassPage
            , /Catln/Doc/dshow ( EAppArg Value /s -> /Catln/Doc/#class = Value /Catln/Doc/#class ) -> /Catln/Doc/Show/ClassPage = Value /Catln/Doc/Show/ClassPage
            , Value /Catln/Doc/#typeInfer
            , Value /Catln/Doc/Show/TypeInfer
            , /Catln/Doc/dshow ( EAppArg Value /s -> /Catln/Doc/#typeInfer = Value /Catln/Doc/#typeInfer ) -> /Catln/Doc/Show/TypeInfer = Value /Catln/Doc/Show/TypeInfer
            , Value /Catln/Doc/#debug
            , Value /Catln/Doc/Show/Debug
            , /Catln/Doc/dshow ( EAppArg Value /s -> /Catln/Doc/#debug = Value /Catln/Doc/#debug ) -> /Catln/Doc/Show/Debug = Value /Catln/Doc/Show/Debug
            , Value /Catln/Doc/#build
            , Value /Catln/Doc/Show/BuildPage
            , /Catln/Doc/dshow ( EAppArg Value /s -> /Catln/Doc/#build = Value /Catln/Doc/#build ) -> /Catln/Doc/Show/BuildPage = Value /Catln/Doc/Show/BuildPage
            ]
        ,
            [ CGType
            , CGType
            , CGType
            , CGType
            , CGType
            , CGType
            , CGType
            , CGType
            , CGType
            , CGType
            , CGType
            , CGType
            , CGType
            , CGType
            , CGClass
                ( False
                , /Catln/Doc/DShow
                ,
                    [ /Data/String
                    , /Catln/CatlnResult..
                    , /Catln/Doc/Show/MD..
                    , /Catln/Doc/Show/ListProgram..
                    , /Catln/Doc/Show/TypePage..
                    , /Catln/Doc/Show/ClassPage..
                    , /Catln/Doc/Show/TypeInfer..
                    , /Catln/Doc/Show/Debug..
                    , /Catln/Doc/Show/BuildPage..
                    ]
                , Just "Represents objects which can be shown in the webdocs.         "
                )
            ]
        ,
            [ /Catln/#md
                ( EAppArg Value /text -> /Data/String = "# Catln WebDocs
                This provides common components and annotations used in Webdocs.
                These include the ones" )
            , /Catln/#md
                ( EAppArg Value /text -> /Data/String = "Represents objects which can be shown in the webdocs." )
            , /Catln/#md
                ( EAppArg Value /text -> /Data/String = "dshow(s) -> /Catln/Doc/DShow" )
            ]
        )
    , ct
        ( CStr "/repo/dir/stack/core/webdoc.ct" )
    ,
        [ ct
            ( CStr "/repo/dir/stack/core/compile.ct" )
        ]
    )
,
    (
        (
            [ /T ( EAppArg Value /x -> /Data/Primitive/Integer )
            , /tst
                ( EAppArg Value /d -> /T ( /x=/Data/Primitive/Integer ) = /T ( EAppArg Value /x -> /Data/Primitive/Integer ) )
                ( EAppArg /f ( EAppArg Value /y -> /Data/Primitive/Integer ) -> ∀/Data/Primitive/Boolean ) -> ∀/Data/Primitive/Boolean
            , /tst
                ( EAppArg Value /d -> /T ( /x=/Data/Primitive/Integer ) = /T ( EAppArg Value /x -> /Data/Primitive/Integer ) )
                ( EAppArg /f ( EAppArg Value /y -> /Data/Primitive/Integer ) -> ∀/Data/Primitive/Boolean ) -> ( /Data/Primitive/False | /Data/Primitive/True ) =
                ( /f
                    ( EAppArg Value /y -> TVArg /x = ( Value /x ↦ TVArg /x ) ) ↦ ( /Data/Primitive/False | /Data/Primitive/True )
                )
            , /ContextIn ( EAppArg Value /value -> /main = Value /main ) ( EAppArg Value /io -> /Catln/IO ) -> TVArg /io = ( Value /io ↦ TVArg /io )
            ]
        ,
            [ CGType
            , CGType
            , CGType
            ]
        ,
            [ /Catln/#md
                ( EAppArg Value /text -> /Data/String = "Tests higher order functions" )
            ]
        )
    , ct
        ( CStr "/repo/dir/test/Integration/code/ho.ct" )
    ,
        [ dir
            ( CStr "/repo/dir/stack/core" )
        ]
    )
,
    (
        ( []
        , []
        , []
        )
    , dir
        ( CStr "/repo/dir/stack/core" )
    ,
        [ ct
            ( CStr "/repo/dir/stack/core/main.ct" )
        ]
    )
]